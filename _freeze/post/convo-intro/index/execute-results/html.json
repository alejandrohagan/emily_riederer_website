{
  "hash": "b3ace748bafbd007bdf05e8bfe4a6359",
  "result": {
    "markdown": "---\ntitle: \"Introducing the {convo} package\"\ndescription: \"An R package for maintaining controlled vocabularies to encode contracts between data producers and consumers\"\nauthor: \"Emily Riederer\"\ndate: \"2020-12-30\"\ncategories: [rstats, pkgdev, data]\nimage: \"featured.png\"\n---\n\n\nBack in September, I wrote about how [controlled vocabularies](/post/column-name-contracts) can help form contracts between data producers and consumers. In short, I argued that aligning on an ontology of stub names for use naming variables in a dataset can improve data documentation, validation, and wrangling with minimal overhead. \n\nHowever, all of these benefits assume *absolute consistency* in the use of the controlled vocabulary. As soon as typos creep into variable names or fields violate the supposed data validation checks that their stubs promise, these vocabularies become more of a liability than an asset by luring data consumers into complacency.\n\nI'm pleased to announced the experimental [`convo`](https://emilyriederer.github.io/convo/index.html) package to enable the definition and application of controlled vocabularies. In this post, I briefly describe the key features. Please see the package website for full documentation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(convo)\n```\n:::\n\n\n## Defining your vocabulary\n\n`convo` uses a YAML specification to define controlled vocabularies. Stubs are defined at each level which can optionally take on additional fields such as `desc` (a human-readable description), `valid` (which specifies `pointblank`-style data validation checks), and `rename` (which specifies how variable names should change under certain computations).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilepath <- system.file(\"\", \"ex-convo.yml\", package = \"convo\")\ncat(readLines(filepath), sep = \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlevel1:\n  ID:\n    desc: Unique identifier\n    valid:\n      - col_vals_not_null()\n      - col_is_numeric()\n      - col_vals_between(1000, 99999)\n  IND:\n    desc: Binary indicator\n    valid:\n      - col_is_numeric()\n      - col_vals_in_set(c(0,1))\n    rename:\n      - when: SUM\n        then: 'N'\n      - when: AVG\n        then: P\n  AMT:\n    desc: Non-negative, summable quantity\n    valid:\n      - col_is_numeric()\n      - col_vals_gte(0)\n  VAL:\n    desc: Value\n    valid:\n      - col_is_numeric()\n    rename:\n      - when: AVG\n        then: VALAV\n  CAT:\n    desc: Category\n    valid:\n      - col_is_character()\n  CD:\n    desc: System-generated code\n    valid:\n      - col_is_character()\n  DT:\n    desc: Calendar date in YYYY-MM-DD format\n    valid:\n      - col_is_date()\nlevel2:\n  A:\n    desc: Type A\n  C:\n    desc: Type C\n  D:\n    desc: Type D\nlevel3:\n  \"\\\\d{4}\": []\n```\n:::\n:::\n\n\nWe can read this into R and retrieve a brief summary. Note that in this case the third-level stub allows for a regular expression to be used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconvo <- read_convo(filepath)\nprint(convo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLevel 1\n- ID\n- IND\n- AMT\n- VAL\n- CAT\n- CD\n- DT\nLevel 2\n- A\n- C\n- D\nLevel 3\n- \\d{4}\n```\n:::\n:::\n\n\nAlternatively, you may define a `convo` as a simple R list object (as shown when `bad_convo` is defined in the following two examples.)\n\n## Assessing vocabulary quality\n\nGood features of a vocabulary stubs include *monosemy* (having only one meaning) and *unique* (being the only thing to mean that thing). Functions `pivot_convo()` and `cluster_convo()` help us spot deviations from these two properties. To illustrate these functions, I'll use a different `convo` than above since that one exhibits both monosemy and uniqueness already.\n\n`pivot_convo()` allows us to obtain all of the level indices at which each stub appears. When the `repeats_only` argument is set to the default value `TRUE`, this function only returns stubs that exist at multiple levels, thus violating monsemy. For example, this function could help us realize that we had used the stub \"CAT\" to refer both to a categorical variable and an animal.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbad_convo <- list(c(\"IND\", \"AMT\", \"CAT\"), c(\"DOG\", \"CAT\"))\npivot_convo(bad_convo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$CAT\n[1] 1 2\n```\n:::\n:::\n\n\nSimilarly, `cluster_convo()` attempts to catch errors in uniqueness by clustering stubs based on string similarity. This can highlight similar but distinct stubs, which might arise when a common word or concept is abbreviated in different ways. In the following example, \"ACCOUNT\", \"ACCT\", and \"ACCNT\" are closely clustered in the second level, which might help us realize that all three are intended to represent a customer's account. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbad_convo <- list(c(\"IND\", \"IS\", \"AMT\", \"AMOUNT\", \"CAT\", \"CD\"),\n              c(\"ACCOUNT\", \"ACCT\", \"ACCNT\", \"PROSPECT\", \"CUSTOMER\"))\nclusts <- cluster_convo(bad_convo)\nplot(clusts[[2]])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n## Evaluating variable names\n\nHaving defined a `convo`, we can next use it to evaluate variable names. The `evaluate_convo()` function accepts a `convo` object and a set of names in a vector. It returns any variable names that violate the controlled vocabulary, listed at the specific level in which the violation occurs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_names <- c(\"ID_A\", \"IND_A\", \"XYZ_D\", \"AMT_B\", \"AMT_Q\", \"ID_A_1234\", \"ID_A_12\")\nevaluate_convo(convo, col_names, sep = \"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLevel 1\n- XYZ_D\nLevel 2\n- AMT_B\n- AMT_Q\nLevel 3\n- ID_A_12\n```\n:::\n:::\n\n\nIf a large number of violations occur, it might be more useful to directly retrieve all of the stubs existing in variable names that are not part of the `convo`. To do this, we can use set operators available in the `compare_convo()` function to examing the unions, intersections, and set differences between our controlled vocabulary and our variable names. Doing so might inspire new candidate stubs that ought to be included in our controlled vocabulary.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconvo_colnames <- parse_stubs(col_names)\ncompare_convo(convo_colnames, convo, fx = \"setdiff\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLevel 1\n- XYZ\nLevel 2\n- B\n- Q\nLevel 3\n- 12\n```\n:::\n:::\n\n\nIf desired, newly uncovered stubs can be added to the `convo` object in R with the `add_convo_stub()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconvo2 <- add_convo_stub(convo, level = 2, stub = \"B\", desc = \"Type B\")\nconvo2 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLevel 1\n- ID\n- IND\n- AMT\n- VAL\n- CAT\n- CD\n- DT\nLevel 2\n- A\n- C\n- D\n- B\nLevel 3\n- \\d{4}\n```\n:::\n:::\n\n\nCurrently, there is not support for editing the YAML specification via R function. New stubs would need to be added manually. However, a completely new YAML file can be created with the `write_convo()` function. This is particularly useful if you are creating a controlled vocabulary for the first time based on an existing set of variables names. First, you may parse them with `parse_stubs()` to create a minimal controlled vocabulary (stubs without descriptions, validation checks, etc.) and then you may write this to a draft YAML file for further customization. \n\n## Validating data fields\n\nThe validation checks specified with `pointblank` verbs in your YAML file can be used to create either a `pointblank` agent or a `pointblank` [YAML file](https://rich-iannone.github.io/pointblank/reference/yaml_read_agent.html) which can be used to consistently apply all of the promised data checks. \n\nThe `pointblank` YAML file may be created with the `write_pb()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_pb(convo, c(\"IND_A\", \"AMT_B\"), filename = \"convo-validation.yml\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(readLines(\"convo-validation.yml\"), sep = \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nread_fn: ~setNames(as.data.frame(matrix(1, ncol = 2)), c(\"IND_A\", \"AMT_B\"))\ntbl_name: ~\nlabel: '[2021-02-09|05:57:05]'\nlocale: en\nsteps:\n- col_is_numeric:\n    columns: matches(\"^([A-Za-z]_){0}IND\")\n- col_vals_in_set:\n    columns: matches(\"^([A-Za-z]_){0}IND\")\n    set:\n    - 0.0\n    - 1.0\n- col_is_numeric:\n    columns: matches(\"^([A-Za-z]_){0}AMT\")\n- col_vals_gte:\n    columns: matches(\"^([A-Za-z]_){0}AMT\")\n    value: 0.0\n```\n:::\n:::\n\n\n\nAlternatively, a validation agent can be created directly with `create_pb_agent()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_to_validate <- data.frame(IND_A = 1, IND_B = 5, DT_B = as.Date(\"2020-01-01\"))\nagent <- create_pb_agent(convo, data_to_validate)\npointblank::interrogate(agent)\n```\n:::\n\n\n## Document fiels and vocabularies\n\n`convo` also offers preliminary support for documentation. \n\nBasic data dictionaries may be created with `describe_names()` which attempts to create definitions for fields based on a user-provided glue string and YAML-specified stub definitions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvars <- c(\"AMT_A_2019\", \"IND_C_2020\")\ndesc_df <- describe_names(vars, convo, desc_str = \"{level1} of {level2} in given year\")\nDT::datatable(desc_df)\n```\n:::\n\n\n![](data-docs.PNG)\n\nAlternatively, the entire controlled vocabulary may be put into a dictionary.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndesc_df <- describe_convo(convo, include_valid = TRUE, for_DT = TRUE)\nDT::datatable(desc_df, escape = FALSE)\n```\n:::\n\n\n![](convo-docs.PNG)\n\n(The tables actually look much nicer when displayed with the full power of `DT`, which also allows for interactive filtering and sorting. Unfortunately, the Javascript behind DT causes a weird conflict with my static site generator weird interactions with my blog theme, so I just show screenshots here.)\n\n## Open issues\n\n`convo` is still very experimental and there are many open questions. Currently, I'm debating many aspects of `convo` specification including:\n\n- What other formats should be allowed for defining a controlled vocabulary? Should there be a spreadsheet/CSV-based format? More support for constructing the object in R directly?\n- Currently, the separators between levels are specified in the function calls. \n  + Should this be part of the `convo` object instead? \n  + Should there be support for varying selectors at different levels (e.g. this would generalize better to using `convo` to validate file names with `/` delimiting directories and subdirectories and `_` or `-` used in parts of file names)\n- `convo` assumes prefix-based schemes with names start and \"grow\" from the beginning. Should suffix-based scheme be supported?\n  + One on hand, this provides significantly more flexibility\n  + On the other hand, I do strongly believe there are advantages to prefixed-based names (e.g. autocomplete, related concepts clustering when sorted) and any additional flexibility will make the initial specification increasingly gnarly for users\n- Should specification allow truly hierarchical naming structures where allowed stubs at level `n+1` vary by the stub at level `n`?\n- Should it be possible to mark some levels are required? Currently, no levels may be \"skipped\" but if five levels are specified, the software permits derived names of lengths fewer or greater than 5 (so long as any existing levels 1-5 follow the format)\n- Would it be useful to be able to programmatically edit the YAML file specification within R? What is the use case for this?\n- Currently, the `describe` function family is rather primitive. I hope to make this more aesthetic or integrate more deeply with `pointblank`\n\nIf you are interested, please take the package for a spin and do not hesitate to get in touch about these issues or any other ideas you have! Seeing more use cases beyond my own helps me understand which of these ideas add value versus unneccesary bloat and confusion. \n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}