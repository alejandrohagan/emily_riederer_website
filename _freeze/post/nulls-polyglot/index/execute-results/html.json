{
  "hash": "106eccb561a1348a8d2b98a9e32cf6ae",
  "result": {
    "markdown": "---\ntitle: \"Oh, I'm sure it's probably nothing\"\ndescription: \"How we do (or don't) think about null values and why the polyglot push makes it all the more important\"\nauthor: \"Emily Riederer\"\ndate: \"2022-09-05\"\ncategories: [rstats, python, sql, data, data-disasters]\nimage: \"featured.jpg\"\n---\n\n\n![ Photo credit to [Davide Ragusa](https://unsplash.com/@davideragusa) on Unsplash ](featured.jpg)\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\nLanguage interoperability and different ways of enabling \"polyglot\" workflows have seemed to take centerstage in the data world recently:\n\n- [Apache Arrow](https://arrow.apache.org/) promises a language-independent memory format for interoperability, - [RStudio](https://www.rstudio.com/blog/rstudio-is-becoming-posit/) its rebranding as Posit to cement their place as a leader in language-agnostic data tooling, \n- RStudio simultaneously announced [Quarto](https://quarto.org/) as an interoperable alternative to RMarkdown which will treat python, Julia, and JS as first-class citizens \n- dbt has released its beta of [python models](https://docs.getdbt.com/docs/building-a-dbt-project/building-models/python-models) to extend is previously SQL-focused paradigm\n\nAs a general matter, these are all exciting advances with great potential to aid in different workflows *when used judiciously*. However, it also poses the question: what cognitive burdens do we alleviate and which do we add when our projects begin to leverage multiple languages? \n\nDespite common data analysis tools like SQL, R, and python being high-level languages with declarative interfaces (in the case of R's `tidyverse` and python's `pandas`), successful usage still requires understanding the underlying assumptions and operations of each tool. There is not such thing as a truly declarative language; only those that generally make decisions that the user likes well-enough to ask for the \"what\" and delegate the \"how\". These differences can emerge at many different levels: such as foundational issues like whether data structures are copied or modified in-place or broader design choices like default hyperparameters in machine learning libraries (e.g. python's `scikitlearn` notoriously uses regularized logistic regression as the default for logistic regression.) Somewhere along that spectrum lies the fickle issue of handling null values.\n\nIn this post, I recap a quick case study of how incautious null handling risks data analysis validity. Then, taking a step back, I compare how R, python, and SQL behave differently when confront with null values and the implications for analysts switching between languages. \n\n## TLDR\n\nA summary of these different behaviors is provided below:\n\n|  \t| **R** \t| **python** \t| **SQL** \t|\n|:---:\t|:---:\t|:---:\t|:---:\t|\n| _Column Aggregation_ \t| NA \t| np: NA<br>pd: Value \t| Value \t|\n| _Row-wise Transformation_ \t| NA \t| NA \t| NA \t|\n| _Joining_ \t| Match by default \t| Match \t| No match \t|\n| _Filtering_ \t| No match \t| Match \t| No match \t|\n\n## Case Study\n\nBefore comparing different languages, let's walk through a brief case study to see all the way that \"lurking\" nulls can surprise a junior analyst in any one language and observe a few different \"contours\" of the problem space.\n\n\n::: {.cell}\n\n:::\n\n\nConsider two tables in a retailer's database. The `spend` table reports total sales by month and store identifier (null if online).\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n  STORE_ID MONTH AMT_SPEND\n1        1     1 100.12011\n2        2     1 100.31441\n3       NA     1 100.40517\n4        1     2  99.67098\n5        2     2  98.39703\n6       NA     2  98.81231\n7        1     3 102.27124\n8        2     3 100.20843\n9       NA     3        NA\n```\n:::\n:::\n\n\nSimilarly, the `returns` table reports returned sales at the same grain.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n  STORE_ID MONTH AMT_RETURN\n1        1     1         NA\n2        2     1   9.972159\n3       NA     1  10.071639\n4        1     2   9.798444\n5        2     2  10.254347\n6       NA     2   9.881071\n7        1     3  10.108880\n8        2     3   9.951398\n9       NA     3   9.849277\n```\n:::\n:::\n\n\nIn both cases, nulls are used in the `'AMT_*'` fields to denote zeros for the respective `month x store_id` combinations`. \n\nTo calculate something as simple as the average gross spend per store across months, an analyst might attempt to write:\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect \n  store_id, \n  avg(amt_spend)\nfrom spend\ngroup by 1\norder by 1\n```\n\n\n| store_id| avg(amt_spend)|\n|--------:|--------------:|\n|       NA|       99.60874|\n|        1|      100.68744|\n|        2|       99.63996|\n:::\n\n\nHowever, because SQL silently drops nulls in column aggregations, the online spend is not appropriately \"penalized\" for its lack of March spend. The averages across all three stores look nearly equal. \n\nNot only is this answer \"wrong\", it can also be thought of as fundamentally changing the **computand** (a word I just made up. In statistics, we talk about estimands as \"the conceptual thing we are trying to estimate with an estimator\". Here, we aren't estimating anything -- just computing. But, there's still a concentual \"thing we are trying to measure\" and in this case, it's our *tools* and not our *methods* that are imposing assumptions on that) to one that answers a fundamentally different question:\n\nInstead of measuring \"average monthly spend in Q1 by store\", we're measuring \"averaging monthly spend in Q1 by store *conditional on* there being spend\". \n\nTo obtain the correct result, one would write:\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect \n  store_id, \n  -- wrong answers\n  avg(amt_spend) as wrong1,  \n  sum(amt_spend) / count(amt_spend) as wrong2,\n  -- right answers\n  sum(amt_spend) / count(1) as right1,\n  avg(coalesce(amt_spend, 0)) as right2\nfrom spend\ngroup by 1\norder by 1\n```\n\n\n| store_id|    wrong1|    wrong2|    right1|    right2|\n|--------:|---------:|---------:|---------:|---------:|\n|       NA|  99.60874|  99.60874|  66.40583|  66.40583|\n|        1| 100.68744| 100.68744| 100.68744| 100.68744|\n|        2|  99.63996|  99.63996|  99.63996|  99.63996|\n:::\n\n\nWith a better understand of gross sales, the analyst might next proceed to compute net sales. \n\nThis first requires joining the `spend` and `returns` tables. Naively, they might attempt:\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect \n  spend.*,\n  returns.amt_return\nfrom \n  spend\n  inner join\n  returns \n  on\n  spend.store_id = returns.store_id and\n  spend.month = returns.month\n```\n\n\n| STORE_ID| MONTH| AMT_SPEND| amt_return|\n|--------:|-----:|---------:|----------:|\n|        1|     1| 100.12011|         NA|\n|        2|     1| 100.31441|   9.972159|\n|        1|     2|  99.67098|   9.798444|\n|        2|     2|  98.39703|  10.254347|\n|        1|     3| 102.27124|  10.108880|\n|        2|     3| 100.20843|   9.951398|\n:::\n\n\nHowever, this once again fails. Why? Although SQL handled nulls \"permissively\" when aggregating a column, it took a stricted stance when making the comparison on `spend.store_id = returns.store_id` in the join clause. SQL doesn't recognize different nulls as equal. To the extent than null means \"I dunno\" versus \"The field is not relevant to this observation\", it's reasonable that SQL should find it hard to decide whether two \"I dunno\"s are equal. \n\nOnce again, this isn't a \"random\" or inconsequential error. Continuing to use this corrupted dataset changes the computand from \"net sales by month\" to \"net sales by month at physical retail locations\".\n\nTo remedy this, we can force `store_id` to take on a value:\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect\n  spend.*,\n  returns.amt_return\nfrom \n  spend\n  inner join\n  returns \n  on\n  coalesce(spend.store_id, 999) = coalesce(returns.store_id, 999) and\n  spend.month = returns.month\n```\n\n\n| STORE_ID| MONTH| AMT_SPEND| amt_return|\n|--------:|-----:|---------:|----------:|\n|        1|     1| 100.12011|         NA|\n|        2|     1| 100.31441|   9.972159|\n|       NA|     1| 100.40517|  10.071639|\n|        1|     2|  99.67098|   9.798444|\n|        2|     2|  98.39703|  10.254347|\n|       NA|     2|  98.81231|   9.881071|\n|        1|     3| 102.27124|  10.108880|\n|        2|     3| 100.20843|   9.951398|\n|       NA|     3|        NA|   9.849277|\n:::\n\n\nAnd next we proceed with computing sales by month net of returns across all stores:\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect\n  spend.month, \n  sum(amt_spend - amt_return) as net_spend\nfrom \n  spend\n  inner join\n  returns \n  on\n  coalesce(spend.store_id, 999) = coalesce(returns.store_id, 999) and\n  spend.month = returns.month\ngroup by 1\norder by 1\n```\n\n\n| month| net_spend|\n|-----:|---------:|\n|     1|  180.6758|\n|     2|  266.9465|\n|     3|  182.4194|\n:::\n\n\nHowever, by now, you should not be surprised that this result is also incorrect. If we inspect the sequence of computations, we realize that SQL is also stricter in its null handing in *rowwise computations* than *column-wise aggregations*. The subtraction of `amt_spend` and `amt_return` obliterates the total when either is null. So, we fail to include the gross spend at Store 1 in January simply because there were no returns (and vice versa for Internet sales in March).\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect\n  spend.month, \n  spend.store_id,\n  amt_spend,\n  amt_return,\n  amt_spend - amt_return as net_spend\nfrom \n  spend\n  inner join\n  returns \n  on\n  coalesce(spend.store_id, 999) = coalesce(returns.store_id, 999) and\n  spend.month = returns.month\n```\n\n\n| month| store_id| amt_spend| amt_return| net_spend|\n|-----:|--------:|---------:|----------:|---------:|\n|     1|        1| 100.12011|         NA|        NA|\n|     1|        2| 100.31441|   9.972159|  90.34225|\n|     1|       NA| 100.40517|  10.071639|  90.33353|\n|     2|        1|  99.67098|   9.798444|  89.87254|\n|     2|        2|  98.39703|  10.254347|  88.14268|\n|     2|       NA|  98.81231|   9.881071|  88.93124|\n|     3|        1| 102.27124|  10.108880|  92.16236|\n|     3|        2| 100.20843|   9.951398|  90.25704|\n|     3|       NA|        NA|   9.849277|        NA|\n:::\n\n\nA few ways to get the correct answer are shown below:\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect\n  spend.month, \n  sum(coalesce(amt_spend,0) - coalesce(amt_return,0)) as right1,\n  sum(amt_spend) - sum(amt_return) as right2\nfrom \n  spend\n  inner join\n  returns \n  on\n  coalesce(spend.store_id, 999) = coalesce(returns.store_id, 999) and\n  spend.month = returns.month\ngroup by 1\norder by 1\n```\n\n\n| month|   right1|   right2|\n|-----:|--------:|--------:|\n|     1| 280.7959| 280.7959|\n|     2| 266.9465| 266.9465|\n|     3| 172.5701| 172.5701|\n:::\n\n\n## Observations\n\nThe preceding example hopefully illustrates a few points:\n\n- Nulls can cause issues in the most basic of analyses\n- Beyond causing random or marginal errors, null handling changes the questions being answered\n- Even within a language, null handling may feel inconsistent (w.r.t. strictness) across different operations\n\nSo, with that, let's compare languages!\n\n\n## Comparison\n\nBelow, we compare how R, SQL, and python handle column aggregation, rowwise transformation, joining, and filtering.\n\n### Aggregation\n\nSQL, as we saw before, simply ignores nulls in aggregation functions.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect \n  sum(x) as sum_x, \n  sum(if(x is null,1,0)) as n_null_x\nfrom tbl\n```\n\n\n| sum_x| n_null_x|\n|-----:|--------:|\n|     3|        1|\n:::\n\n\nBuilt by and for statistician's, R is scandalized at the very idea of attempting to do math with null columns. For aggregation functions, it returns `NA` as a form of protest should any entry of the vector provided be null. (This can be overridden with the `na.rm` parameter.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1,2,NA)\nsum(x)\n\ndf <- data.frame(x = x)\ndplyr::summarize(df, x = sum(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n::: {.cell-output-display}\n|  x|\n|--:|\n| NA|\n:::\n:::\n\n\nWhen it comes to python, well, it depends. Base and `numpy` operations act more like R whereas `pandas` aggregation acts more like SQL.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nimport numpy as np\nx = [1,2,np.nan]\ny = [3,4,5]\ndf = pd.DataFrame({'x':x,'y':y})\nsum(x)\nnp.sum(x)\ndf.agg({'x': ['sum']})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nnan\nnan\n       x\nsum  3.0\n```\n:::\n:::\n\n\n### Transformation\n\nAll of SQL, R, and python return NA when `NA`s are used in atomic or rowwise transformations.\n\nIn SQL:\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect *, x-y as z\nfrom tbl\n```\n\n\n|  x|  y|  z|\n|--:|--:|--:|\n|  1|  3| -2|\n|  2|  4| -2|\n| NA|  5| NA|\n:::\n\n\nIn R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = c(1,2,NA), y = 3:5)\ndplyr::mutate(df, z = x-y)\n\ndf$z <- with(df, x-y)\ndf\n```\n\n::: {.cell-output-display}\n|  x|  y|  z|\n|--:|--:|--:|\n|  1|  3| -2|\n|  2|  4| -2|\n| NA|  5| NA|\n\n|  x|  y|  z|\n|--:|--:|--:|\n|  1|  3| -2|\n|  2|  4| -2|\n| NA|  5| NA|\n:::\n:::\n\n\nIn python:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnp.array(x) - np.array(y)\ndf.assign(z = lambda d: d.x - d.y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([-2., -2., nan])\n     x  y    z\n0  1.0  3 -2.0\n1  2.0  4 -2.0\n2  NaN  5  NaN\n```\n:::\n:::\n\n\n### Joining \n\nThe situation with joins may feel like the opposite of aggregation. Here, R and python's most popular data wrangling packages are more permissive than SQL.\n\nAs we saw in the case study, SQL does not match on nulls.\n\nConsider `tbl1` and `tbl2` as shown below:\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect * from tbl1\n```\n\n\n|  A|B  |X    |\n|--:|:--|:----|\n|  1|NA |TRUE |\n:::\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect * from tbl2\n```\n\n\n|  A|B  |Y     |\n|--:|:--|:-----|\n|  1|NA |FALSE |\n:::\n\n\nAttempts to join return no results:\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect tbl1.*, tbl2.Y \nfrom \n  tbl1 inner join tbl2 \n  on \n  tbl1.A = tbl2.A and \n  tbl1.B = tbl2.B\n```\n\n\n|  A|B  |X  |y  |\n|--:|:--|:--|:--|\n:::\n\n\nIn contrast, default behavior for base R's `merge` and `dplyr` *does match* on nulls. (Although, either behavior can be altered with the `incomparables` or `na_matches` arguments, respectively.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- data.frame(A = 1, B = NA, X = TRUE)\ndf2 <- data.frame(A = 1, B = NA, Y = FALSE)\nmerge(df1, df2, by = c(\"A\", \"B\"))\ndplyr::inner_join(df1, df2, by = c(\"A\", \"B\"))\n```\n\n::: {.cell-output-display}\n|  A|B  |X    |Y     |\n|--:|:--|:----|:-----|\n|  1|NA |TRUE |FALSE |\n\n|  A|B  |X    |Y     |\n|--:|:--|:----|:-----|\n|  1|NA |TRUE |FALSE |\n:::\n:::\n\n\nSimilarly, `pandas` also matches on nulls for joining.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nimport pandas as pd\ndf1 = pd.DataFrame([[1, np.nan, True]], columns = ['A','B','X'])\ndf2 = pd.DataFrame([[1, np.nan, False]], columns = ['A','B','Y'])\npd.merge(df1, df2, on = ['A','B'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   A   B     X      Y\n0  1 NaN  True  False\n```\n:::\n:::\n\n\n`R` and `python`'s behavior here seems most surprising. One might expect joining to work the same as raw logical evaluation works. However, neither language \"likes\" null comparison in its raw form. Instead, the default behavior is intentionally altered in these higher-level joining functions.\n\nIn R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA == NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nIn python:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnp.nan == np.nan\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\n```\n:::\n:::\n\n\n### Filtering\n\nFinally, both SQL and R drop null records used in filtering statements since comparisons with these values are incapable of returning a TRUE/FALSE value that is used to subset the rows. In python, however, pandas does preserve nulls in filter conditions. \n\nUsing the same `tbl1` shown above, we can also confirm that SQL proactively drops nulls in where clauses where they cannot be readily compared to non-null values. This seems quite consistent with its behavior in the joining case.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect A, B, X \nfrom tbl1 \nwhere B != 1\n```\n\n\n|  a|b  |x  |\n|--:|:--|:--|\n:::\n\n\nBoth base R and `dplyr` paradigms follow suit here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- data.frame(A = 1, B = NA, X = TRUE)\ndf1[df1$B != 1,]\ndplyr::filter(df1, B != 1)\n```\n\n::: {.cell-output-display}\n|   |  A|B  |X  |\n|:--|--:|:--|:--|\n|NA | NA|NA |NA |\n\n|  A|B  |X  |\n|--:|:--|:--|\n:::\n:::\n\n\nHowever, bucking the trend, multiple approaches to subsetting `pandas` data will not drop nulls in filtering comparisons.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndf1 = pd.DataFrame([[1, np.nan, True]], columns = ['A','B','X'])\ndf1[df1.B != 1]\ndf1.query('B != 1')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   A   B     X\n0  1 NaN  True\n   A   B     X\n0  1 NaN  True\n```\n:::\n:::\n\n\n## Conclusion\n\nIn data computation and analysis, the devil is often in the details. It's not breaking news that low-level reasoning on the careful handling of null values can jeopardize the resulting analyses. However, as analysts take on increasingly complex tasks and using a plehora of different tools, it's more important than ever for both data producers and consumers to consider the choices they are making in encoding and handling these values across the stack.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}