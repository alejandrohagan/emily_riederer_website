{
  "hash": "5aef2651137698b90c4dd9ceaf718760",
  "result": {
    "markdown": "---\ntitle: \"projmgr: Managing the human dependencies of your projects\"\ndescription: \"A walkthrough of using the projmgr package for GitHub-based project management via R\"\nauthor: \"Emily Riederer\"\ndate: \"2020-05-14\"\ncategories: [rstats, workflow]\nimage: \"featured.png\"\naliases:\n  - /post/projmgr/\n---\n\n\nMany tools and packages aim to eliminate the pain and uncertainty of technical project management. For example, `git`, `make`, `Docker`, `renv`, and `drake` are just a few existing tools that enable collaboration, manage softwatre dependencies, and promote reproducibility. However, there is no analogous gold standard for managing the most time-consuming and unpredictable depencies in data analysis work: our fellow humans. \n\nThis was my initial motivation for developing the [`projmgr`](https://emilyriederer.github.io/projmgr/) R package. Earlier this year, I was delighted to receive an invitation to speak about this package at [UseR!2020](https://user2020.r-project.org/), but unfortunately the conference was rightly cancelled due to COVID-19 risk. \n\nHowever, as the pandemic has pushed data teams towards remote work, the challenges of effective team communication and project management have become even more acute.  Without the passive context sharing that comes through collocation, it's easier for misunderstandings to arise either because stakeholders were misaligned from the outset or because their vision of a project independently drifts in different directions. \n\nOvercommunication is key, but this in itself taxes productivity. Communication with our collaborators and customers is often spread across Zoom, email, Slack, GitHub, and sometimes third-party project management tools like Jira or Trello. Switching between these different software tools and frames of mind knocks analysts out of their flow and detracts from getting work done. \n\n`projmgr` offers a solution: an opinionated interface for conducting end-to-end project management with R, using GitHub issues and milestones as the backend. Key features of this package include bulk generation of GitHub issues and milestones from a YAML project plan and automated creation of status updates with user-friendly text summaries and plots. \n\nIn this post, I summarize my would-have-been talk to highlight features of the package that are particularly useful in the current climate.\n\n## Project Management Goals\n\nComparing how we manage tools sheds some light on what is needed in a technical project management tool. Good practices from software engineering include:\n\n- **Establishing clear expectations** both for our code (with unit and integration tests) and the environment (with Dockerfiles and dependency management)\n- **Ensuring new development aligns with the objective** with version control and continuous integration\n- **Broadcasting updates through multiple mechanisms** such as commit messages, `NEWS.md` files, semantic versioning, and (in the case of R in particular) CRAN's reverse dependency checks\n\nIn contrast, in project management:\n\n- **Expectations can be ambiguous** as we communicate with fluid, flexible language\n- **Priorities can change** due to misunderstandings or private context (and without so much as a commit message to warn us!)\n- **Progress is not always observable** without active effort from the performing team\n\nAll of these issues can be mitigated through proactive communication. However, any time spent making update decks or writing emails is time *not* spent on the next data product, model, or analysis. The beauty of many of our software developer tools is these features are largely *automated* and *integrated* into our workflows with minimal friction or time cost. \n\nIn the rest of this post, I will demonstrate how `projmgr` can be used to tackle these three challenges by: making a plan, assessing priorities, and sharing updates.\n\n## Making a Plan\n\nThe first step to project management is making a plan and getting buy-in from all relevant stakeholders, including target piees of work to deliver on different timelines. `projmgr` allows you to easily articulate a project plan in human-readable YAML and then seamlessly bulk-upload a set of GitHub issues and milestones. \n\nFor example, suppose in a data analysis, we write out the following plan and save it to the file `plan.yml`:\n\n\n::: {.cell engine.opts='{\"file\":\"plan.yml\"}'}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n- title: Data cleaning and validation\n  description: >\n    We will conduct data quality checks,\n    resolve issues with data quality, and\n    document this process\n  due_on: 2018-12-31T12:59:59Z\n  issue:\n    - title: Define data quality standards\n      body: List out decision rules to check data quality\n      assignees: [emilyriederer]\n      labels: [a, b, c]\n    - title: Assess data quality\n      body: Use assertthat to test decision rules on dataset\n      labels: [low]\n    - title: Resolve data quality issues\n      body: Conduct needed research to resolve any issues\n\n- title: Exploratory data analysis\n  description: >\n    Create basic statistics and views to better\n    understand dataset and relationships\n  issue:\n    - title: Summary statistics\n      body: Calculate summary statistics\n    - title: Visualizations\n      body: Create univariate and bivariate plots\n```\n:::\n\n\nThis format is fairly human-readable, accessible, and easy to edit. It can be shared with a team to get alignment.\n\nOnce a plan has been made, `projmgr` can read this into R as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(projmgr)\nplan <- read_plan(\"plan.yml\")\n```\n:::\n\n\nTo ensure our plan was read in correctly, we can print a quick summary:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplan\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPlan: \n1. Data cleaning and validation (3 issues) \n2. Exploratory data analysis (2 issues) \n```\n:::\n:::\n\n\nNext, we can create a connection to a GitHub repo and push our plan to the repo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrepo <- create_repo_ref(repo_owner = 'emilyriederer', repo_name = 'experigit')\npost_plan(repo, plan)\n```\n:::\n\n\nThis results in the creation of the following set of issues and milestones:\n\n![Screenshot of GitHub milestones page](post_plan.png)\n\nFrom there, we can continue to open, close, and comment on our issues as we would with any others.\n\nSimilarly, with `read_todo()` and `post_todo()`, you can send additional issues to your repository that aren't nested under milestones.\n\n## Analyzing Priorities\n\nOf course, the fun thing about plans is that plans can change. GitHub issues provide a flexible interface for projects to be *dynamic* and always open for commentary, feedback, requests, and new ideas. Beyond the issues created in our plan, we can use `projmgr` to understand organically occuring GitHub issues and to potentially incorporate them into our projects.\n\n`projmgr` facilitates this by looking at issue metadata. Specifically, it can filter, extract, and pivot any type of custom label names. For example, let's consider the `RForwards/tasks` repository.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nforwards <- create_repo_ref(\"forwards\", \"tasks\")\nissues <- get_issues(forwards) %>% parse_issues()\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nThe `labels_name` column contains lists of entries. One common use of labels in this repo is to denote the team responsible for completing a task, denoted by the tag `\"{name}-team\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(issues[, c('labels_name', 'number', 'title')])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               labels_name number\n1              survey-team     41\n2 help wanted, survey-team     40\n3                              35\n4                              33\n5                              32\n6                              31\n                                                                             title\n1                                                       useR! 2018 survey analysis\n2                                        Create new Community section on Data page\n3                       Guidelines on Ableist language in Talks and Presentations.\n4                                             Rainbow R : LGBT+ in the R Community\n5 Inviting R community and event organizers from Africa and Asia to the RUG slack.\n6                                                      Joint event with Trans*Code\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(unlist(issues$labels_name))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"survey-team\"       \"help wanted\"       \"conferences-team\" \n[4] \"admin\"             \"on-ramps-team\"     \"branding\"         \n[7] \"teaching-team\"     \"social-media-team\" \"community-team\"   \n```\n:::\n:::\n\n\nThe `listcol_filter()` function lets us filter our data only to the isues relevant to a certain list column entry. For example, the data currently contains 26 issues. But we can filter down to those only assigned to *any* team or a *specific* team. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(issues)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 26\n```\n:::\n\n```{.r .cell-code}\n# any issue with a label ending in 'team'\nlistcol_filter(issues, \"labels_name\", matches = \"-team$\", is_regex = TRUE) %>% nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14\n```\n:::\n\n```{.r .cell-code}\n# any issue with a label matching 'teaching-team'\nlistcol_filter(issues, \"labels_name\", matches = \"teaching-team\") %>% nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nAlternatively, we can create new columns by extracting data from our labels. For example, we can create a `team` column in our dataset by extracting the labels ending in `\"-team\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nissues[, c('labels_name', 'number', 'title')] %>%\n  listcol_extract(\"labels_name\", regex = \"-team$\") %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               labels_name number\n1              survey-team     41\n2 help wanted, survey-team     40\n3                              35\n4                              33\n5                              32\n6                              31\n                                                                             title\n1                                                       useR! 2018 survey analysis\n2                                        Create new Community section on Data page\n3                       Guidelines on Ableist language in Talks and Presentations.\n4                                             Rainbow R : LGBT+ in the R Community\n5 Inviting R community and event organizers from Africa and Asia to the RUG slack.\n6                                                      Joint event with Trans*Code\n    team\n1 survey\n2 survey\n3   <NA>\n4   <NA>\n5   <NA>\n6   <NA>\n```\n:::\n:::\n\n\nFinally, the `listcol_pivot()` helped function identifies all labels matching a regex, extract all the \"values\" from the key-value pair, and pivots these into boolean columns. For example, the following code makes a widened dataframe with a separate column for each team. `TRUE` denotes the fact that that team is responsible for that issue.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nissues_by_team <-\nissues[, c('labels_name', 'number', 'title')] %>%\n  listcol_pivot(\"labels_name\", \n                regex = \"-team$\",\n                transform_fx = function(x) sub(\"-team\", \"\", x), \n                delete_orig = TRUE) \nhead(issues_by_team)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  number\n1     41\n2     40\n3     35\n4     33\n5     32\n6     31\n                                                                             title\n1                                                       useR! 2018 survey analysis\n2                                        Create new Community section on Data page\n3                       Guidelines on Ableist language in Talks and Presentations.\n4                                             Rainbow R : LGBT+ in the R Community\n5 Inviting R community and event organizers from Africa and Asia to the RUG slack.\n6                                                      Joint event with Trans*Code\n  survey conferences on-ramps teaching social-media community\n1   TRUE       FALSE    FALSE    FALSE        FALSE     FALSE\n2   TRUE       FALSE    FALSE    FALSE        FALSE     FALSE\n3  FALSE       FALSE    FALSE    FALSE        FALSE     FALSE\n4  FALSE       FALSE    FALSE    FALSE        FALSE     FALSE\n5  FALSE       FALSE    FALSE    FALSE        FALSE     FALSE\n6  FALSE       FALSE    FALSE    FALSE        FALSE     FALSE\n```\n:::\n:::\n\n\nThis has many convenient use-cases, including being able to quickly see the number falling into each category.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolSums(issues_by_team[, -c(1,2)])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      survey  conferences     on-ramps     teaching social-media    community \n           4            1            3            2            2            2 \n```\n:::\n:::\n\n\nOther examples of metadata that could be included as issue labels include subjective assessments of priority and difficulty (e.g. `'Priority: 1`, `'Difficulty: Hard`), the part of a project effected (e.g. `stage:eda`, `stage:tuning`), and much more. The only limit is the maintainer's willingness to adhere to labelling conventions.\n\n## Reporting Progress\n\nOnce we are managing our project in GitHub, `projmgr` offers multiple ways to summarize progress. \n\nWe can retrieve issues from any repository with `get_issues()` (which returns the full results from the GitHub API) and `parse_issues()` (which structures particularly relevant columns into a dataframe). For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nissues <- repo %>% get_issues() %>% parse_issues()\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nWe can use the `report_progress()` family of functions to share an update on the status of each issue, now linked back to the GitHub reposiitory.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreport_progress(issues)\n```\n\n::: {.cell-output-display}\n<p/> <strong> Data cleaning and validation </strong> <em>( 100 % Complete - 3 / 3 )</em> <ul  class = 'report_progress' style = 'list-style: none;'> <li>  &#9745; <a href = 'https://github.com/emilyriederer/experigit/issues/147'>Resolve data quality issues</a> </li> <li>  &#9745; <a href = 'https://github.com/emilyriederer/experigit/issues/146'>Assess data quality</a> </li> <li>  &#9745; <a href = 'https://github.com/emilyriederer/experigit/issues/145'>Define data quality standards</a> </li> </ul> <strong> Exploratory data analysis </strong> <em>( 50 % Complete - 1 / 2 )</em> <ul  class = 'report_progress' style = 'list-style: none;'> <li>  &#9744; <a href = 'https://github.com/emilyriederer/experigit/issues/149'>Visualizations</a> </li> <li>  &#9745; <a href = 'https://github.com/emilyriederer/experigit/issues/148'>Summary statistics</a> </li> </ul> <p/>\n:::\n:::\n\n\nBeyond simple text summaries, we can also share a number of visualizations such as Gantt charts or taskboards. To demonstrate this, I'll switch to an example of a more complex set of issues, hypothetically pulled from GitHub and stored to as a `data.frame` in a variable called `pkg_issues`.\n\n\n::: {.cell}\n\n:::\n\n\nUsing HTML and CSS grid, `report_taskboard()` function creates an aesethetic and interactive views of your work.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreport_taskboard(pkg_issues, in_progress_when = is_assigned_to(\"emilyriederer\"), hover = TRUE)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div class = ' qtbrylxqwx '> <style>.taskboard{display: grid;grid-gap: 1%;grid-template-columns: 1fr 1fr 1fr;margin-bottom: 50px;}.head{background-color: #a9a9a9;border: 1px solid #d3d3d3;text-align: center;font-weight: strong;}.task{text-align: center;padding: 2%;margin: 2%;border: 1px solid #d3d3d3;box-shadow: 2px 2px 5px grey;transition-duration:0.5s;}.qtbrylxqwx .task:hover{margin: 0%;padding: 4%;}.qtbrylxqwx .ns{background-color:#f0e442;}.qtbrylxqwx .ip{background-color:#56b4e9;}.qtbrylxqwx .dn{background-color:#009e73;}div.taskboard a, div.taskboard a:visited{color: black;text-decoration: none;}div.taskboard a:hover{color: black;text-decoration: underline;}div.taskboard a:active{color: white;}</style> <div class = 'taskboard'><div class = 'head'>Not Started</div><div class = 'head'>In Progress</div><div class = 'head'>Done</div><div class = 'task ns '>  Extend report() support to LaTeX  </div> <div class = 'task ip '>  Add get for events data  </div> <div class = 'task dn '>  Add parse for events data  </div><div class = 'task ns '>  API mocking for testing  </div> <div class = 'task ip '>  Validate YAML read from read fxs  </div> <div class = 'task dn '>  Add browse and help functions  </div><div class = 'task ns '>  Write vignette to demo visualization  </div> <div></div> <div class = 'task dn '>  Add metadata function examples to vignettes  </div><div class = 'task ns '>  Add JSON support for plan / todo  </div> <div></div> <div></div></div> </div>\n`````\n:::\n:::\n\n\n`report_taskboard()` includes many different options including linking back to each individual issue and changing the colors of each column.\n\nNot only is this visual summary more pleasant, but it also enables better insights for stakeholders by allowing you to flexibly share what work is being actively worked on at the moment (beyond simple open / closed status). This is controlled by the `in_progress_when` option and a number of helper function-factories to allow you to semantically described what constitutes progress. The above example uses the `is_labeled_with()` option. Other options include:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls('package:projmgr')[grep(\"^is_*\", ls('package:projmgr'))]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"is_assigned\"       \"is_assigned_to\"    \"is_created_before\"\n [4] \"is_due\"            \"is_due_before\"     \"is_in_a_milestone\"\n [7] \"is_in_milestone\"   \"is_labeled\"        \"is_labeled_with\"  \n[10] \"is_part_closed\"   \n```\n:::\n:::\n\n\n## Want to Learn More?\n\nTo learn more and explore other use cases and code flows, please check out the [articles](https://emilyriederer.github.io/projmgr/articles/index.html) on the `projmgr` website. This showcases other features such as using `projmgr` to send emails^[I have yet to test this with `blastula`, but I hope to update the vignette with that in mind], coordinate hackathons, track KPIs, documenting conversations, and more. \n\nThis project is still under active development, and I welcome any ideas of new features via [GitHub](https://github.com/emilyriederer/projmgr). \n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}